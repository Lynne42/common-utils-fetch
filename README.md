# 功能
- [✅] 1. 支持超时设置
- [✅] 2. 支持请求和响应拦截器
- [✅] 3. 错误统一处理
- [✅] 4. JSON自动序列化
- [✅] 5. 取消请求: 通过 AbortController
- [✅] 6. 重试策略
- [✅] 7. 上传下载进度回调
- 8. 可选：缓存和去重机制
- 9. 可选：请求队列管理： 可在业务侧单独封装，职责单一且隔离
- 10. 可选：并发请求限制：可在业务侧单独封装，职责单一且隔离

## 超时设置

支持超时设置，默认5秒超时
1. 可通过 options参数 timeout设置
2. 可全局设置timeout属性

超时时间是一个全局配置参数，对于后续应用到的所有request, 都会默认应用这个时间
也可以在使用request的时候，通过option传递单个超时时间， 这个超时时间只作用于当前一个request请求

如果请求超时，会取消请求，同时返回new Error('Request timed out'), error.name = 'TimeoutError'


## 请求和响应拦截器
请求拦截器和响应拦截器，是对Request和Response的修改操作，允许设置多个请求或者响应拦截器，对于多个拦截器，系统是一次处理的
- 请求拦截器是对请求参数 url和option配置做拦截并进行修改的操作
- 响应拦截器是对返回的response进行处理的操作

### 请求拦截器
请求拦截器是对请求参数 url和option配置做拦截并进行修改的操作

对于请求拦截器，输入应该是一个Request对象，返回也应该是一个Request对象，比如通常建一个请求拦截器， 里面可以全局配置url,配置前缀等，也可以配置header Auth鉴权，或者当requestType非json的时候配置content-type

如果定义了多个请求拦截器，在请求之前，会根据定义顺序依次执行拦截器函数，也就是先进先出

请求拦截器按注册顺序执行 → 队列（FIFO）

### 响应拦截器
响应拦截器是对返回的response进行处理的操作

在这里我们通常可以对返回的response进行处理
- 根据response.ok进行响应错误处理
- 根据responseType进行不同数据的处理，比如如果是json数据的话需要对json进行反序列化将json字符串转换为json对象

响应拦截器按注册顺序逆序执行 → 栈（LIFO）

### 定义数据结构
多个请求拦截器的情况下，请求需要按照定义时的顺序依次执行，典型的数据结构就是 队列（FIFO）

而多个响应拦截器，由于最好遵循一个请求拦截器和一个响应拦截器有对应关系的情况（当然两个完全没有关系也不影响），如果有关系的情况下，那么请求拦截器是先进先出， 响应拦截器应该对应请求拦截器，比如第一个请求拦截器，那对应的就是最以后一个响应拦截器，这样的话， 响应拦截器就是一个 栈（LIFO）

我们可以选择使用Array，将注册id保存到数组里面，同时使用Map保存 id --> 拦截器函数的映射

注册拦截器时，id保存到数组中，同时函数保存到Map中，返回id
注销拦截器时，通过给定的id， 将id从数组中删除，同时将对应的拦截器函数从Map中删除

使用两种数据结构是因为，我们一方面包保证注册顺序，同时也要注意注销时使用的id要正确。
- 如果只使用Map来保存数据，这个id的顺序没法保证能拿到正序和倒序数据
- 如果只使用Array来保存数据，拦截器函数保存在数组中， id只能通过下标来表示，这样如果注销的时候，如果直接诶删除某一位，下标变化了，就对应不上了，如果将某一位置为空，那么对于暴力注册或者一些压力测试就会存在性能问题

因此这里考虑使用Array+Map的两种数据结构来管理数据。但可能也存在设计过度的情况，因为通常来说定义2,3个拦截器基本已经足够了，通常在项目中看到的也只是存在一个拦截器而已

## 错误统一处理
- 如果网络错误导致请求不可达等情况，错误会直接暴露出来
- 如果是超时错误，会设置error.name = 'TimeoutError', 也会直接暴露出来，通过name属性区分
- 如果是取消请求， 会设置error.name = 'AbortError', 也会直接暴露出来，通过name属性区分
- 其他业务错误(请求可达)，需要通过response.ok区分是否响应成功，做后面的业务处理



## JSON自动序列化
因为通常来说，
- 请求在传递参数的时候，基本上传递的是json对象，同时在浏览器查看传参的时候，json对象的方式看起来更加直观，所以将json序列化的操作封装到请求体内部
- 但是对于json结构的响应来说，虽然fetch返回的结果也是json字符串，但是由于响应体存在200或者非200的情况，这个需要在客户端在统一错误处理或者逻辑处理，这部分暂时不封装

## 取消请求: 通过 AbortController
fetch原生支持取消请求，是通过AbortController实现的，所以在封装里面，我们也支持取消请求，这个一方面用于客户端主动取消，一方面，当设置的请求超时的时候， 也需要取消请求

通过signal参数可以接收用户设置的AbortController
```
if (userSignal) {
    if (userSignal.aborted) controller.abort();
    else userSignal.addEventListener('abort', () => controller.abort(), { once: true });
}
```
通过监听abort去取消当前的请求

## 重试策略
当一个请求失败的时候， 我们有时候需要重试请求， 这个在之前的项目经验中， 通常是在客户端实现的，当请求失败返回到客户端，客户端会进行请求重试
在这里，可以将请求重试的操作放到request内部去做，只需要配置重试次数即可，当达到重试次数后，会将最后一次出现的错误返回个客户端
但是这里有个问题，如果客户端是接口轮询，并且没有使用setTimeout来实现这个轮询，同时又配置的重试策略，可能会初夏意想不到的问题，所以需要考虑使用场景


## 上传下载进度
### 下载进度
由于fetch原生支持stream流式数据，可以通过流式数据接收计算进度。这里之所以在库中流式读取，再把进度通过回调函数回调给客户端，是因为我们关注的是进度，而最终的结果仍然是完整的结果，由客户端去处理结果。

这与我们常用的AI流式接收数据不同，AI流式接收的主题目的是做流式展示数据，它本身需要的就是流片段逐字展示，而这里下载进度通常是对于文件，图片，音视频 等资源来说的，我们关注下载进度，下载完成后需要整体去处理数据，因此可以将下载进度封装到库中

1. fetch 的 Response.body 是 ReadableStream<Uint8Array>，你可以通过 getReader() 逐块读取
2. Content-Length 头（res.headers.get('Content-Length')）若存在，就能计算百分比；若不存在只能回报“已接收字节数”
3. 流式分片接收之后，需要将这些片段重新组合成response body，返回到客户端，由客户端统一处理数据，客户端可以使用.json()，.text()， .blob()等根据类型统一处理不同的数据

## 缓存
适用场景：
- 静态配置数据（如国家列表、分类字典、版本信息）
- 用户频繁访问同一API（如分页、搜索、下拉选项）
非实时、重复访问多、可接受短期过期数据的请求，非常适合缓存

不需要的场景：
1. 文件或图片下载接口这个一般会触发浏览器缓存策略，调用者通常无需处理
2. 后端提供了ETag / Cache-Control 机制， 这个直接使用HTTP缓存策略即可，调用端无需重复逻辑

缓存通常是针对Get请求，同时应该是一个被动的选择，需要调用者配置是否需要缓存

缓存通常来说有两个地方
1. 将数据缓存到内存，这个占用量大，内存消耗大
2. 将数据缓存到IndexedDB
不管是缓存到哪里，都需要考虑配置
    - 缓存时长，过期时间
    - 最大缓存数据量
  
需要考虑当缓存数据量超出时，要如何清理以及清理策略

## 去重
防止同一时间多个请求调用同一资源，常见的情况是按钮点击没有做锁的概念，导致按钮快速多次点击，触发多次接口调用

封装库中去重操作由于更多的是针对get请求， 这里暂不考虑在封装库中去做去重， 而是应该把这个放到客户端去做，因为不管是get还是post涉及到按钮的都应该主动做点击去重

